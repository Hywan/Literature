<?xml version="1.0" encoding="utf-8"?>

<overlay xmlns="http://hoa-project.net/xyl/xylophone">
<yield id="yContent">

  <h1 id="Mini_tutoriel">Mini-tutoriel</h1>

  <p>Hoa se définit avant tout comme un ensemble de bibliothèques. Toutefois,
  pour <strong>engager</strong> le développement avec Hoa, il est nécessaire
  de proposer des mécanismes dignes d'un framework afin de faciliter son
  <strong>apprentissage</strong>, son <strong>utilisation</strong> et ses
  <strong>contributions</strong>. C'est pourquoi Hoa propose un aspect
  framework qui doit être vu comme une <strong>démonstration de
  faisabilité</strong>, ou un <em>proof-of-concept</em>.</p>

  <p>Le mini-tutorial a pour but de vous familiariser avec l'aspect framework
  de Hoa en se plongeant dans la création d'une application de A à Z. Nous ne
  détaillerons pas ici tous les concepts sous-jacents aux fonctionnalités d'Hoa
  mises en œuvre, en revanche nous vous proposerons des liens pour les
  découvrir dans le manuel d'apprentissage.</p>

  <h2 id="Table_des_matieres">Table des matières</h2>

  <tableofcontents id="main-toc" />

  <h2 id="Le_projet" for="main-toc">Le projet</h2>

  <p>Nous allons développer le <strong>blog</strong> du très célèbre
  <a href="https://secure.wikimedia.org/wikipedia/en/wiki/Gordon_Freeman">
  docteur Gordon Freeman</a>. La création d'un blog nécessite de gérer plusieurs
  types de données (des articles et des commentaires) qui seront ensuite
  utilisés sur différentes pages (liste des billets, page d'un billet avec ses
  commentaires).</p>

  <h2 id="Preparer_son_environnement" for="main-toc">Préparer son
  environnement</h2>

  <p>Hoa est suffisamment souple pour ne pas vous imposer d'environnement. Nous
  allons vous proposer une architecture en guise d'exemple après avoir installé
  Hoa pour enfin tester l'application dans sa version minimale.</p>

  <h3 id="Installer_Hoa" for="main-toc">Installer Hoa</h3>

  <p>Nous allons installer Hoa directement depuis les sources qui sont gérées
  par <a href="http://git-scm.com">Git</a>. <strong>Central</strong> est le
  dépôt qui rassemble toutes les bibliothèques qui composent Hoa. Il est
  disponible à l'adresse
  <a href="http://git.hoa-project.net/Central.git">http://git.hoa-project.net/Central.git</a>
  ou sur le mirroir
  <a href="http://github.com/hoaproject/Central.git">Github</a>.</p>
  <p>L'emplacement où est installé Hoa n'a aucune influence sur le
  fonctionnement de l'application. D'une manière plus générale, Hoa est conçu
  pour être installé une fois et être utilisé par plusieurs applications. Nous
  conseillons donc de l'installer dans le répertoire <code>/usr/local/lib/
  </code> qui est le répertoire habituel des bibliothèques utilisateur sous
  Unix, ou son équivalent <code>C:\Program Files\</code> sous Windows.</p>

  <p>Pour respecter cette recommandation, il faudra user d'un lien symbolique
  lors de l'installation, par exemple :</p>
  <pre><code class="language-shell">$ git clone http://git.hoa-project.net/Central.git /usr/local/Hoa.central
$ ln -s /usr/local/Hoa.central/Hoa /usr/local/lib/Hoa</code></pre>

  <h3 id="Creer_notre_application" for="main-toc">Créer notre application</h3>

  <p>Maintenant que Hoa est installé, nous allons pouvoir installer une
  application au moyen d'un autre dépôt Git, celui de base pour l'aspect
  framework d'Hoa :</p>
  <tabs class="plain">
    <tablist>
      <tab for="tunix_install_framework" selected="true">Unix</tab>
      <tab for="twindows_install_framework">Windows</tab>
    </tablist>

    <tabpanel id="tunix_install_framework">
      <pre><code class="language-shell">$ cd ~/Development/GordonsApp/
$ git clone http://git.hoa-project.net/Embryo.git .</code></pre>
    </tabpanel>

    <tabpanel id="twindows_install_framework">
      <pre><code class="language-shell">> cd %UserProfile%\Development\GordonsApp\
> git clone http://git.hoa-project.net/Embryo.git .</code></pre>
    </tabpanel>
  </tabs>

  <p>Premier réflexe, nous allons préciser à l'application où se trouve Hoa en
  exécutant le scripts <code>whereishoa</code> (ou <code>whereishoa.bat</code>
  sous Windows) dans le dossier <code>Data/Bin/</code>.
  Attention, si vous n'utilisez pas une installation « standard » de PHP,
  vous devrez retoucher la première ligne de <code>whereishoa</code> ou la
  variable <code>PHP</code> de <code>whereishoa.bat</code>.</p>
  <p>Ces scripts vont modifier entre autre le fichier
  <code>Data/Core.link.php</code> qui, lorsqu'il est inclu,
  <strong>liera</strong> notre application avec Hoa. Cette approche présente
  plusieurs avantages : peu importe où est installé Hoa, notre application va
  toujours inclure <code>Data/Core.link.php</code> et nous n'aurons qu'à
  relancer <code>Data/Bin/whereishoa</code> pour la lier à Hoa ; ce qui
  implique que notre application pourra <strong>choisir</strong> entre
  plusieurs versions de Hoa si plusieurs existent. Le fichier
  <code>Data/Core.link.php</code> agit comme un <strong>routeur</strong> vers
  Hoa ce qui nous évitera de devoir modifier notre application si nous déplaçons
  ou modifions Hoa.</p>
  <tabs class="plain">
    <tablist>
      <tab for="tunix_where_is_hoa" selected="true">Unix</tab>
      <tab for="twindows_where_is_hoa">Windows</tab>
    </tablist>

    <tabpanel id="tunix_where_is_hoa">
      <pre><code class="language-shell">$ chmod u+x Data/Bin/whereishoa
$ Data/Bin/whereishoa
** Where is Hoa **

Ready to redefine the path to Hoa?
We need to redefine it in:
  • the Core.link.php file;
  • the configuration file;
  • the configuration cache file.

There we go [y/n]? y

A very simple question: where is Hoa so?
> /usr/local/lib/hoa▋</code></pre>
    </tabpanel>

    <tabpanel id="twindows_where_is_hoa">
      <pre><code class="language-shell">> .\Data\Bin\whereishoa.bat
** Where is Hoa **

Ready to redefine the path to Hoa?
We need to redefine it in:
  • the Core.link.php file;
  • the configuration file;
  • the configuration cache file.

There we go [y/n]? y

A very simple question: where is Hoa so?
C:\Program Files\Hoa▋</code></pre>
    </tabpanel>
  </tabs>

  <p>L'aspect framework fournit deux <strong>scripts</strong> qui étendent
  les deux scripts fournis par Hoa, à savoir <code>myapp</code> et
  <code>myapp.bat</code>, que l'on trouvera dans <code>Data/Bin/</code>. Ces
  scripts sont <strong>dédiés</strong> à l'application en lui offrant des
  <strong>outils</strong> bien pratiques, comme un debugger, un petit
  serveur HTTP (Bhoa), de quoi manipuler les configurations, la
  documentation, les tests etc.</p>
  <p>Pour se les approprier un peu plus, nous pouvons les renommer :</p>
  <tabs class="plain">
    <tablist>
      <tab for="tunix_rename_script" selected="true">Unix</tab>
      <tab for="twindows_rename_script">Windows</tab>
    </tablist>

    <tabpanel id="tunix_rename_script">
      <pre><code class="language-shell">$ chmod u+x Data/Bin/myapp
$ Data/Bin/myapp
// Homescreen.
$ mv Data/Bin/myapp Data/Bin/gordonsapp
$ Data/Bin/gordonsapp
// Homescreen.</code></pre>
    </tabpanel>

    <tabpanel id="twindows_rename_script">
      <pre><code class="language-shell">> .\Data\Bin\myapp.bat
// Homescreen.
> move Data/Bin/myapp.bat Data/Bin/gordonsapp.bat
> .\Data\Bin\gordonsapp.bat
// Homescreen.</code></pre>
    </tabpanel>
  </tabs>

  <p>Pour plus de facilités, nous pouvons placer notre dossier
  <code>Data/Bin/</code> dans le <code>PATH</code> afin de pouvoir accéder
  à nos scripts depuis n'importe où sur le disque. Nous admettrons que
  <code>gordonsapp</code> est placé dans le <code>PATH</code> pour les exemples
  de code suivants.</p>

  <h3 id="Tester_notre_nouvelle_application" for="main-toc">Tester notre nouvelle application</h3>

  <p>Pour tester l'application, un fichier de test existe déjà dans
  <code>Application/Public/</code>. Nous pourrons l'exécuter de plusieurs
  façons. La première, simplement avec PHP en ligne de commande :</p>
  <tabs class="plain">
    <tablist>
      <tab for="tunix_test_new_app" selected="true">Unix</tab>
      <tab for="twindows_test_new_app">Windows</tab>
    </tablist>
    <tabpanel id="tunix_test_new_app">
      <pre><code class="language-shell">$ php Application/Public/index.php
Hello you! I'm your first Hoa-based application \o/.</code></pre>
    </tabpanel>
    <tabpanel id="twindows_test_new_app">
      <pre><code class="language-shell">> php Application\Public\index.php
Hello you! I'm your first Hoa-based application \o/.</code></pre>
    </tabpanel>
  </tabs>
  <p>Mais il faut admettre que ce n'est pas très drôle. Nous pouvons utiliser un
  serveur HTTP avec PHP pour accéder à notre application via un navigateur
  Internet. Si vous possédez déjà un serveur HTTP avec PHP vous pouvez vous
  référer à l'annexe <a href="@ll:chapter=Appendix_http_servers">Configuration
  des serveurs HTTP </a> pour découvrir la configuration nécessaire à Hoa. Pour
  le développement nous vous conseillons d'utiliser Bhoa, qui est un petit
  serveur HTTP embarqué réservé au développement (pas à la production !) et qui
  ne nécessite aucune configuration. Bhoa jouant le rôle de serveur HTTP, il a
  besoin de communiquer avec PHP qui lui se charge interpréter les pages.
  Bhoa utilise PHP FastCGI pour exécuter PHP, nous allons donc devoir le
  démarrer sur le port standard (9000) :</p>
  <tabs class="plain">
    <tablist>
      <tab for="tunix_start_phpcgi" selected="true">Unix</tab>
      <tab for="twindows_start_phpcgi">Windows</tab>
    </tablist>
    <tabpanel id="tunix_start_phpcgi">
      <pre><code class="language-shell">$ php-cgi -b 127.0.0.1:9000&amp;amp;</code></pre>
    </tabpanel>
    <tabpanel id="twindows_start_phpcgi">
      <pre><code class="language-shell">// dans une nouvelle invite de commande
> php-cgi -b 127.0.0.1:9000</code></pre>
    </tabpanel>
  </tabs>
  <p>Enfin, Hoa fournit une abstraction des chemins à travers le protocole
  <code>hoa://</code> qui propose le chemin
  <code>hoa://Application/Public/</code> pour accéder à notre dossier
  public. Nous allons utiliser ce chemin pour définir la racine du serveur ;
  ainsi :</p>
  <tabs class="plain">
    <tablist>
      <tab for="tunix_start_bhoa" selected="true">Unix</tab>
      <tab for="twindows_start_bhoa">Windows</tab>
    </tablist>
    <tabpanel id="tunix_start_bhoa">
      <pre><code class="language-shell">$ gordonsapp http:bhoa --root hoa://Application/Public/
Server is up, on tcp://127.0.0.1:8888!
Root: hoa://Application/Public/.

Waiting for connection… ▋</code></pre>
    </tabpanel>
    <tabpanel id="twindows_start_bhoa">
      <pre><code class="language-shell">> gordonsapp http:bhoa --root hoa://Application/Public/
Server is up, on tcp://127.0.0.1:8888!
Root: hoa://Application/Public/.

Waiting for connection… ▋</code></pre>
    </tabpanel>
  </tabs>
  <p>Par défaut Bhoa écoute le port 8888. Il faut des droits <code>root</code>
  pour écouter le port 80. Nous allons laisser Bhoa fonctionner durant tout le
  développement en gardant la console qui l'exécute ouverte et en ouvrant une
  nouvelle console pour la suite. En essayant de joindre la page
  <a href="http://127.0.0.1:8888"><code>127.0.0.1:8888</code></a>, nous pourrons
  lire le message de bienvenue :</p>
  <tabs class="plain">
    <tablist>
      <tab for="tunix_curl_test" selected="true">Unix</tab>
      <tab for="twindows_curl_test">Windows</tab>
    </tablist>
    <tabpanel id="tunix_curl_test">
      <pre><code class="language-shell">$ curl 127.0.0.1:8888
Hello you! I'm your first Hoa-based application \o/.</code></pre>
    </tabpanel>
    <tabpanel id="twindows_curl_test">
      <pre><code class="language-shell">> curl 127.0.0.1:8888
Hello you! I'm your first Hoa-based application \o/.</code></pre>
    </tabpanel>
  </tabs>
  <p>Note: par commodité nous utilisons <a href="http://curl.haxx.se/">cURL</a>
  pour voir le code source des pages générées. Il est bien sûr possible
  d'utiliser un navigateur web pour afficher ces même pages, comme nous
  le ferons plus loin dans ce tutoriel.</p>

  <h3 id="Architecture_par_defaut" for="main-toc">Architecture par défaut</h3>

  <p>Prenons quelques minutes pour étudier l'architecture que l'on a
  déployé :</p>
  <tabs class="plain">
    <tablist>
      <tab for="tunix_tree" selected="true">Unix</tab>
      <tab for="twindows_tree">Windows</tab>
    </tablist>
    <tabpanel id="tunix_tree">
      <pre><code class="language-shell">$ gordonsapp tree --list-directory --depth 2
~/Development/GordonsApp/
|-- Application/     — notre application
|   |-- Public/      —   son dossier public (visible depuis l'extérieur)
|-- Data/            — données de l'application
|   |-- Bin/         —   scripts (étend Hoa/Bin/)
|   |-- Etc/         —   configurations, locales…
|   |-- Lost+found/  —   perdus ou trouvés (toujours vide normalement !)
|   |-- Module/      —   bibliothèques utilisateurs réservéees à l'application
|   |-- Temporary/   —   fichiers et dossiers temporaires
|   |-- Variable/    —   caches, bases de données, logs, tests…</code></pre>
    </tabpanel>
    <tabpanel id="twindows_tree">
      <pre><code class="language-shell">> gordonsapp tree --list-directory --depth 2
~/Development/GordonsApp/
|-- Application/     — notre application
|   |-- Public/      —   son dossier public (visible depuis l'extérieur)
|-- Data/            — données de l'application
|   |-- Bin/         —   scripts (étend Hoa/Bin/)
|   |-- Etc/         —   configurations, locales…
|   |-- Lost+found/  —   perdus ou trouvés (toujours vide normalement !)
|   |-- Module/      —   bibliothèques utilisateurs réservéees à l'application
|   |-- Temporary/   —   fichiers et dossiers temporaires
|   |-- Variable/    —   caches, bases de données, logs, tests…</code></pre>
    </tabpanel>
  </tabs>
  <p>Une application est réellement constituée de deux dossiers :
  <code>Application/</code> et <code>Data/</code> ; Hoa étant la plupart du
  temps, comme nous l'avons vu précédemment, placé autre part et référencé au
  moyen du script <code>whereishoa</code>.</p>
  <p>Cette architecture est celle <strong>proposée</strong> par
  <strong>défaut</strong> mais elle peut être complètement modifiée. Rien
  n'est <strong>fixé</strong> car nous aurons pour bonne pratique d'accéder aux
  ressources et données à travers le protocole <code>hoa://</code> qui peut
  être vu comme une suite de liens symboliques. De ce fait, si nous déplaçons un
  dossier par exemple, nous n'aurons qu'à mettre à jour le protocole
  <code>hoa://</code> sans avoir à modifier le code de notre
  application.</p>

  <h2 id="Routeur_et_controleur" for="main-toc">Routeur et contrôleur</h2>

  <p>Une application peut se découper en plusieurs parties, ou plus précisément
  en trois couches, respectivement modèle, vue et contrôleur (MVC). Le modèle
  sert à manipuler les données, la vue à les afficher et le contrôleur à faire
  le lien entre les deux. Quand notre application reçoit une requête, elle va
  utiliser un routeur pour extraire des données. Ces données seront ensuite
  transmises à un dispatcheur. Enfin, le dispatcheur appellera le contrôleur
  qui traitera la requête.</p>

  <p>Dans notre blog, nous voulons disposer de 2 actions :</p>
  <ul>
    <li>afficher la liste des articles ;</li>
    <li>afficher un article en particulier.</li>
  </ul>
  <p>Puisque c'est le routeur qui fera l'aiguillage, nous devons créer 2 routes
  dans le fichier <code>Application/Public/index.php</code>.
  Ainsi, ce fichier contiendra le routeur HTTP et le dispatcheur vers des
  contrôleurs, ainsi que les 2 routes suivantes :</p>
  <ul>
    <li><code>i</code> pour afficher la liste des articles</li>
    <li><code>a</code> pour afficher un article en particulier.</li>
  </ul>
  <p>La règle <code>i</code> sera accessible depuis le chemin de l'URI <code>/
  </code> et la règle <code>a</code> depuis <code>/article-<em>id</em>.html</code>.
  Nous allons avoir un contrôleur qui sera une classe avec deux méthodes, une
  pour chaque action. Nous remplaçons le <code>echo</code> du fichier
  <code>Application/Public/index.php</code> par le code suivant :</p>
  <pre><code class="language-php">$dispatcher = new Hoa\Dispatcher\Basic();
$router     = new Hoa\Router\Http();
$router->get('i', '/', 'blog', 'index')
       ->get('a', '/article-(?&amp;lt;id>\d+)\.html', 'blog', 'article');

$dispatcher->dispatch($router);</code></pre>
  <p>Par défaut le contrôleur est représenté par une classe
  <code>Application\Controller\<em>ControllerName</em></code>. Nous voulons
  appeler notre contrôleur <code>blog</code>, c'est pourquoi nous allons écrire
  la classe <code>Application\Controller\Blog</code>, avec deux méthodes :
  <code>IndexAction</code> et <code>ArticleAction</code>, respectivement pour
  les règles <code>i</code> et <code>a</code>. Ainsi :</p>
  <pre><code class="language-php">namespace Application\Controller {

class Blog extends \Hoa\Dispatcher\Kit {

    public function IndexAction ( ) {

        echo 'Gordon\'s blog index.', "\n";
    }

    public function ArticleAction ( $id ) {

        echo 'Article n°', $id, '.', "\n";
    }
}

}</code></pre>
  <p>Nous voyons que nos actions reçoivent en argument les données extraites du
  routeur. Ainsi le paramètre <code>$id</code> est extrait grâce à la règle
  <code>(?&amp;amp;lt;id&amp;amp;gt;\d+)</code> de la route <code>a</code>.</p>
  <p>A l'aide de cURL ou d'un navigateur, nous allons joindre
  <a href="http://127.0.0.1:8888"><code>127.0.0.1:8888</code></a> :</p>
  <tabs class="plain">
    <tablist>
      <tab for="tunix_curl_article" selected="true">Unix</tab>
      <tab for="twindows_curl_basic">Windows</tab>
    </tablist>
    <tabpanel id="tunix_curl_article">
      <pre><code class="language-shell">$ curl 127.0.0.1:8888/
Gordon's blog index
$ curl 127.0.0.1:8888/article-1.html
Article n°1
$ curl 127.0.0.1:8888/article-42.html
Article n°42</code></pre>
    </tabpanel>
    <tabpanel id="twindows_curl_basic">
      <pre><code class="language-shell">> curl 127.0.0.1:8888/
Gordon's blog index
> curl 127.0.0.1:8888/article-1.html
Article n°1
> curl 127.0.0.1:8888/article-42.html
Article n°42</code></pre>
    </tabpanel>
  </tabs>
  <p>Tout fonctionne bien ! Mais ce ne sera pas toujours le cas. Par exemple, si
  nous appelons une URI qui n'est pas comprise par le routeur, une erreur sera
  levée :</p>
  <tabs class="plain">
    <tablist>
      <tab for="tunix_curl_wrong_uri" selected="true">Unix</tab>
      <tab for="twindows_curl_wrong_uri">Windows</tab>
    </tablist>
    <tabpanel id="tunix_curl_wrong_uri">
      <pre><code class="language-shell">$ curl 127.0.0.1:8888/foobar
Uncaught exception (Hoa\Router\Exception\NotFound):
Hoa\Router\Http::route(): (6) Cannot found an appropriated rule to route foobar.
in hoa://Library/Router/Http.php at line 490.</code></pre>
    </tabpanel>
    <tabpanel id="twindows_curl_wrong_uri">
      <pre><code class="language-shell">> curl 127.0.0.1:8888/foobar
Uncaught exception (Hoa\Router\Exception\NotFound):
Hoa\Router\Http::route(): (6) Cannot found an appropriated rule to route foobar.
in hoa://Library/Router/Http.php at line 490.</code></pre>
    </tabpanel>
  </tabs>
  <p>Plus précisément, une exception de type
  <code>Hoa\Router\Exception\NotFound</code> sera levée lors du dispatche. Nous
  pouvons capturer cette exception et réagir en conséquence, par exemple en
  indiquant qu'une erreur s'est produite, en modifiant la fin du fichier
  <code>Application/Public/index.php</code> ainsi :</p>
  <pre><code class="language-php">try {

    $dispatcher->dispatch($router);
}
catch ( Hoa\Router\Exception\NotFound $e ) {

    echo 'Your page seems to be not found /o\.', "\n";
}</code></pre>
  <p>L'exception affichée à l'utilisateur est remplacée par notre erreur :</p>
  <tabs class="plain">
    <tablist>
      <tab for="tunix_curl_not_found" selected="true">Unix</tab>
      <tab for="twindows_curl_not_found">Windows</tab>
    </tablist>
    <tabpanel id="tunix_curl_not_found">
      <pre><code class="language-shell">$ curl 127.0.0.1:8888/foobar
Your page seems to be not found /o\.</code></pre>
    </tabpanel>
    <tabpanel id="twindows_curl_not_found">
      <pre><code class="language-shell">> curl 127.0.0.1:8888/foobar
Your page seems to be not found /o\.</code></pre>
    </tabpanel>
  </tabs>
  <p>Le <a href="@ll:chapter=Routerdispatcher">chapitre Router + Dispatcher = ♥
  </a> du manuel d'apprentissage vous permettra de comprendre en détail ces
  deux outils.</p>

  <h2 id="Modele_de_donnees" for="main-toc">Modèle de données</h2>

  <p>Les données d'une application sont souvent stockées dans des outils tiers,
  comme des bases de données. Notre application doit être capable d'accéder et
  de manipuler facilement ces données. Hoa propose la bibliothèque
  <code>Hoa\Model</code> pour créer et manipuler des modèles.</p>

  <h3 id="Schema_des_donnees" for="main-toc">Schéma des données</h3>

  <p>Le blog sera constitué d'articles auxquels seront associés des
  commentaires. Un article est caractérisé par un identifiant, un titre, une
  date et un contenu. Un commentaire est caractérisé par un identifiant, un
  auteur, une date et un contenu. Un lien existe entre les commentaires et les
  articles à travers leurs identifiants respectifs.</p>
  <p>Le schéma complet au format SQL peut être retrouvé dans
  <a href="http://hg.hoa-project.net/Sandbox">le dépôt <code>Sandbox/</code></a>
  dans le fichier <code>GordonsBlog/Data/Variable/Database/Blog.sql</code>. Nous
  donnons ici la description des tables :</p>
  <pre><code class="language-sql">CREATE TABLE article (
    id      INTEGER,
    title   VARCHAR(255),
    posted  TIMESTAMP,
    content LONGVARCHAR,

    PRIMARY KEY(id)
);

CREATE TABLE comment (
    id      INTEGER,
    article INTEGER,
    author  VARCHAR(31),
    posted  TIMESTAMP,
    content LONGVARCHAR,

    PRIMARY KEY(id)
    FOREIGN KEY(article) REFERENCES article(id)
);</code></pre>
  <p>Pour créer la base de données, nous allons utiliser le moteur
  <a href="http://sqlite.org/">SQLite</a> et sa commande <code>sqlite3</code> en
  étant préalablement placé dans le dossier
  <code>Data/Variable/Database/</code> :</p>
  <tabs class="plain">
    <tablist>
      <tab for="tunix_init_database" selected="true">Unix</tab>
      <tab for="twindows_init_database">Windows</tab>
    </tablist>
    <tabpanel id="tunix_init_database">
      <pre><code class="language-shell">$ cd Data/Variable/Database
$ sqlite3 -init Blog.sql -echo Blog.sqlite</code></pre>
    </tabpanel>
    <tabpanel id="twindows_init_database">
      <pre><code class="language-shell">> cd Data\Variable\Database
> sqlite3 -init Blog.sql -echo Blog.sqlite</code></pre>
    </tabpanel>
  </tabs>
  <p>Notre base de données est maintenant créée. Nous allons écrire le modèle
  correspondant.</p>

  <h3 id="Modele_des_donnees" for="main-toc">Modèle des données</h3>

  <p>Nous allons créer deux fichiers, un pour chaque entité de notre modèle dans
  le dossier <code>Application/Model</code>.</p>
  <p>Nous commençons par écrire l'entité <code>Comment</code> comme étant la
  classe <code>Application\Model\Comment</code> en fonction de notre
  schéma :</p>
  <pre><code class="language-php">namespace Application\Model {

class Comment extends \Hoa\Model {

    /**
     * @invariant id: boundinteger(0);
     */
    protected $_id;

    /**
     * @invariant article: relation('Application\Model\Article', 1);
     */
    protected $_article;

    /**
     * @invariant author: regex('[\w\d\'\- ]+', boundinteger(1, 42));
     */
    protected $_author;

    /**
     * @invariant posted: boundinteger(
     *                        timestamp('1 january 1999'),
     *                        timestamp('now')
     *                    );
     */
    protected $_posted;

    /**
     * @invariant content: string(boundinteger(1, 4096));
     */
    protected $_content;



    protected function construct ( ) {

        $this->setMappingLayer(\Hoa\Database\Dal::getLastInstance());

        return;
    }
}

}</code></pre>
  <p>Nous avons écrit les contraintes de validation à travers Praspel, un
  langage d'annotation (nous pouvons compléter ou remplacer Praspel avec les
  méthodes <code>validate<em>Name</em></code>). Nous avons également défini le
  lien vers nos données avec la méthode
  <code>Hoa\Model\Model::setMappingLayer</code>. Maintenant voyons l'entité
  <code>Article</code> comme étant la classe
  <code>Application\Model\Article</code> toujours en fonction de notre
  schéma :</p>
  <pre><code class="language-php">namespace Application\Model {

class Article extends \Hoa\Model {

    /**
     * @invariant id: boundinteger(0);
     */
    protected $_id;

    /**
     * @invariant title: string(boundinteger(1, 255));
     */
    protected $_title;

    /**
     * @invariant posted: boundinteger(
     *                        timestamp('1 january 1999'),
     *                        timestamp('now')
     *                    );
     */
    protected $_posted;

    /**
     * @invariant content: string(boundinteger(1));
     */
    protected $_content;

    /**
     * @invariant comments: relation('Application\Model\Comment', boundinteger(0));
     */
    protected $_comments;



    protected function construct ( ) {

        $this->setMappingLayer(\Hoa\Database\Dal::getLastInstance());

        return;
    }

    public function open ( Array $constraints = array() ) {

        $constraints = array_merge($this->getConstraints(), $constraints);

        if(!isset($constraints['id']))
            throw new \Hoa\Model\Exception('The constraint “id” is needed.', 0);

        $data = $this->getMappingLayer()
                     ->prepare(
                         'SELECT id, title, content ' .
                         'FROM   article ' .
                         'WHERE  id = :id'
                     )
                     ->execute($constraints)
                     ->fetchAll();
        $this->map($data[0]);
        $this->comments->map(
            $this->getMappingLayer()
                 ->prepare(
                     'SELECT id, posted, author, content ' .
                     'FROM   comment '.
                     'WHERE  article = :article'
                 )
                 ->execute(array('article' => $constraints['id']))
                 ->fetchAll()
        );

        return;
    }

    public function getShortList ( ) {

        return $this->getMappingLayer()->query(
            'SELECT id, title, posted FROM article ORDER BY id DESC'
        )->fetchAll();
    }
}

}</code></pre>
  <p>À nouveau, nous avons écrit les contraintes de validation pour chaque
  donnée et nous avons défini le lien vers nos données. En plus, nous avons
  écrit le comportement de la méthode <code>open</code> avec la gestion des
  contraintes et des relations (à travers l'attribut <code>comments</code>).
  Enfin, nous avons la méthode <code>getShortList</code> qui exploite l'entité
  sans la modifier.</p>
  <p>Le <a href="@ll:chapter=Model">chapitre Modèle</a> du manuel
  d'apprentissage vous permettra d'aller plus loin avec le modèle. En attendant
  nous allons exploiter notre modèle dans notre contrôleur.</p>

  <h3 id="Depuis_un_controleur" for="main-toc">Depuis un contrôleur</h3>

  <p>Notre contrôleur <code>Application\Controller\Blog</code> comporte déjà
  deux actions sous la forme de méthodes : <code>IndexAction</code> et
  <code>ArticleAction</code>. Nous allons les enrichir pour utiliser le modèle
  et afficher les données brutes.</p>
  <p>Pour la méthode <code>IndexAction</code>, nous allons afficher la liste des
  articles présents sur le blog. Pour cela, nous allons nous aider de la méthode
  <code>getShortList</code> de <code>Application\Model\Article</code> :</p>
  <pre><code class="language-php">public function IndexAction ( ) {

    $article = new \Application\Model\Article();
    $list    = $article->getShortList();

    echo "\n", str_repeat(' ', 31) . '★ Gordon\'s blog ★', "\n\n",
         'Here is the list of all articles I have written:', "\n";

    foreach($list as $l)

        echo '    #' .  $l['id'], ' ', date('d/m/Y', $l['posted']), ' — ',
             wordwrap($l['title'], 59, "\n" . str_repeat(' ', 20), true),
             "\n";

    echo "\n";

    return;
}</code></pre>
  <p>Pour la méthode <code>ArticleAction</code>, nous allons afficher un article
  avec ses commentaires en fonction de l'identifiant de l'article demandé :</p>
  <pre><code class="language-php">public function ArticleAction ( $id ) {

    $article = new \Application\Model\Article();
    $article->open(array('id' => $id));

    echo "\n", str_repeat(' ', 31) . '★ Gordon\'s blog ★', "\n\n",
         $article->title, "\n\n",
         wordwrap($article->content, 80, "\n", true), "\n\n",
         str_repeat(' ', 34), str_repeat('-', 10), "\n\n";

    foreach($article->comments as $comment)
        echo $comment->author, ' • ', date('d/m/Y', $comment->posted), "\n",
             wordwrap($comment->content, 70, "\n", true), "\n\n";

    echo "\n";

    return;
}</code></pre>

  <h3 id="Testons" for="main-toc">Testons !</h3>

  <p>N'oublions pas de modifier notre fichier d'amorçage <code>index.php</code>
  pour lui ajouter la connexion à notre base de données qui sera exploitée par
  notre modèle (à l'aide de la méthode <code>getLastInstance</code> de
  <code>Hoa\Database\Dal</code>) ; ainsi :</p>
  <pre><code class="language-php">Hoa\Database\Dal::initializeParameters(array(
    'connection.list.default.dal' => Hoa\Database\Dal::PDO,
    'connection.list.default.dsn' => 'sqlite:hoa://Data/Variable/Database/Blog.sqlite',
    'connection.autoload'         => 'default'
));

$dispatcher = new Hoa\Dispatcher\Basic();
$router     = new Hoa\Router\Http();
$router->get('i', '/', 'blog', 'index')
       ->get('a', '/article-(?&amp;lt;id>\d+)\.html', 'blog', 'article');

try {

    $dispatcher->dispatch($router);
}
catch ( Hoa\Router\Exception\NotFound $e ) {

    echo 'Your page seems to be not found /o\.', "\n";
}</code></pre>
  <p>Enfin, nous allons tester notre application un peu plus enrichie ! À l'aide
  de cURL, nous allons afficher le résultat de notre index et d'un
  article :</p>
  <tabs class="plain">
    <tablist>
      <tab for="tunix_curl_rich" selected="true">Unix</tab>
      <tab for="twindows_curl_rich">Windows</tab>
    </tablist>
    <tabpanel id="tunix_curl_rich">
      <pre><code class="language-shell">$ curl 127.0.0.1:8888/

                               ★ Gordon's blog ★

Here is the list of all articles I have written:
    #5 07/01/2001 — G-Man or the hard deal
    #4 03/01/2001 — ping -f Nihilanth
    #3 16/12/2000 — I think I have made a blunder at Black Mesa
    #2 15/12/2000 — Great party in the Anomalous Materials department with
                    collegues!
    #1 05/05/2000 — Dr. Isaac Kleiner, my mentor, has hired me at Black Mesa
                    Research Facility
    #0 18/11/1999 — Call me Ph.D!

$ curl 127.0.0.1:8888/article-0.html

                               ★ Gordon's blog ★

Call me Ph.D!

My thesis was accepted. What a long labor! Well, it is finally over. The harder
part was to resume the title. You know, in Theoretical Physics, thesis have
always very short and concise titles. Mine is quite simple; here it is:
Observation of Einstein-Podolsky-Rosen Entanglement on Supraquantum Structures
by Induction Through Nonlinear Transuranic Crystal of Extremely Long Wavelength
(ELW) Pulse from Mode-Locked Source Array. I can gladly send you a copy if you
want.

                                  ----------

Isaac Kleiner • 19/12/1999
Nice work Gordon. Hope we will work together in a near future!

Mummy • 19/12/1999
I really donnot understand what you do but I am very proud of my
little Gordy :-). xoxo, your Mummy.</code></pre>
    </tabpanel>
    <tabpanel id="twindows_curl_rich">
      <pre><code class="language-shell">> curl 127.0.0.1:8888/

                               ★ Gordon's blog ★

Here is the list of all articles I have written:
    #5 07/01/2001 — G-Man or the hard deal
    #4 03/01/2001 — ping -f Nihilanth
    #3 16/12/2000 — I think I have made a blunder at Black Mesa
    #2 15/12/2000 — Great party in the Anomalous Materials department with
                    collegues!
    #1 05/05/2000 — Dr. Isaac Kleiner, my mentor, has hired me at Black Mesa
                    Research Facility
    #0 18/11/1999 — Call me Ph.D!

> curl 127.0.0.1:8888/article-0.html

                               ★ Gordon's blog ★

Call me Ph.D!

My thesis was accepted. What a long labor! Well, it is finally over. The harder
part was to resume the title. You know, in Theoretical Physics, thesis have
always very short and concise titles. Mine is quite simple; here it is:
Observation of Einstein-Podolsky-Rosen Entanglement on Supraquantum Structures
by Induction Through Nonlinear Transuranic Crystal of Extremely Long Wavelength
(ELW) Pulse from Mode-Locked Source Array. I can gladly send you a copy if you
want.

                                  ----------

Isaac Kleiner • 19/12/1999
Nice work Gordon. Hope we will work together in a near future!

Mummy • 19/12/1999
I really donnot understand what you do but I am very proud of my
little Gordy :-). xoxo, your Mummy.</code></pre>
    </tabpanel>
  </tabs>
  <p>Notre application exploite plusieurs <strong>couches</strong>. Nous avons
  les <strong>données</strong> qui sont stockées dans une base de données. Notre
  <strong>abstraction</strong> avec <code>Hoa\Database\Dal</code> et une
  utilisation <strong>standard</strong> du langage SQL nous permettent de
  changer de gestionnaire de bases de données <strong>sans modifier</strong> le
  code de notre application. De plus, les données sont manipulées par notre
  application à travers un <strong>modèle</strong> les réprésentant (à l'aide de
  <code>Hoa\Model</code>). Si les données viennent à changer d'emplacement
  ou de <strong>format</strong>, mettre à jour le modèle sera la seule tâche à
  faire. Elle peut nécessiter une quantité de travail non négligeable mais la
  tâche est <strong>isolée</strong> : seul le modèle sera à modifier, pas le
  reste de l'application. Enfin, <code>Hoa\Model</code> peut servir à
  l'élaboration d'outils de gestion de données plus complexes de par sa
  conception.</p>

  <h2 id="Les_vues" for="main-toc">Les vues</h2>

  <p>Nous allons donner au <em>Gordon's blog</em> une meilleure interface
  graphique afin de pouvoir l'afficher dans un navigateur. Nous allons commencer
  par déclarer les vues puis les attacher à nos données à travers notre
  contrôleur pour enfin tester le tout.</p>
  <p>Hoa propose un système d'interface graphique, appelé XYL, pour écrire nos
  vues.</p>

  <h3 id="Document_principal" for="main-toc">Document principal</h3>

  <p>Notre document principal sera <code>Application/View/Main.xyl</code> et
  accueillera nos différentes pages. Nous utilisons pour celà les
  <em>overlays</em>. Les <a href="@ll:chapter=Xyl#Overlay"><em>overlays</em></a>
  sont des composants que nous pouvons insérer dans un document.</p>

  <p>Chaque page sera un <em>overlay</em> par rapport au document principal,
  nous y préciserons donc un identifiant auquel ceux-ci pourront venir
  s'attacher. Ainsi le document principal s'écrira :</p>
  <pre><code class="language-markup">&amp;lt;?xml version="1.0" encoding="utf-8"?>

&amp;lt;document xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;title>&amp;lt;value bind="?title" /> — Gordon's blog&amp;lt;/title>

  &amp;lt;header>
    &amp;lt;h1>Gordon's blog&amp;lt;/h1>
  &amp;lt;/header>

  &amp;lt;div id="main" />

  &amp;lt;footer>
    &amp;lt;p>Author: Gordon Freeman © 1999-2001. This blog is powered by
    &amp;lt;a href="http://hoa-project.net/">Hoa&amp;lt;/a> and
    &amp;lt;a href="http://php.net/">PHP&amp;lt;/a>.&amp;lt;/p>
  &amp;lt;/footer>
&amp;lt;/document></code></pre>
  <p>C'est un document très simple. Le titre est variable et nos pages
  s'ajouteront dans le composant portant l'identifiant <code>main</code>.</p>

  <h3 id="Liste_des_articles" for="main-toc">Liste des articles</h3>

  <p>Nous proposons de ranger les vues du blog dans le dossier
  <code>Application/View/Blog/</code>. Ainsi, la liste des articles sera
  représentée par le fichier <code>Index.xyl</code> et va définir un
  <em>overlay</em> pour l'identifiant <code>main</code> :</p>
  <pre><code class="language-markup">&amp;lt;?xml version="1.0" encoding="utf-8"?>

&amp;lt;overlay xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;div id="main">
    &amp;lt;p>Here is the list of all articles I have written:&amp;lt;/p>
    &amp;lt;ul>
      &amp;lt;li bind="?articles">
        &amp;lt;value bind="?posted" /> — &amp;lt;a href="@a:id=(?id)" bind="?title" />
      &amp;lt;/li>
    &amp;lt;/ul>
  &amp;lt;/div>
&amp;lt;/overlay></code></pre>
  <p>Nous avons une liste qui va s'accrocher sur les arbres
  <code>articles</code> et les feuilles de ces arbres vont servir à afficher la
  date, le lien et le titre des articles. Ce mécanisme est appelé le
  <a href="@ll:chapter=Xyl#Binding_et_yielding"><em>binding</em></a>. Pour
  écrire le lien, nous utilisons la règle <code>a</code> définit dans notre
  routeur pour accéder à un article.</p>

  <h3 id="Un_article_avec_ses_commentaires" for="main-toc">Un article avec ses
    commentaires</h3>

  <p>Maintenant, nous allons écrire la vue d'un article dans le fichier
  <code>Article.xyl</code>, toujours en tant qu'<em>overlay</em>. Elle affichera
  le titre de l'article, son contenu et les commentaires associés. Nous avons
  fait le choix de définir un composant pour représenter les commentaires sous
  le nom <code>comment</code> et défini dans le fichier
  <code>Comment.xyl</code>. Ainsi :</p>
  <pre><code class="language-markup">&amp;lt;?xml version="1.0" encoding="utf-8"?>
&amp;lt;?xyl-use href="hoa://Application/View/Blog/Comment.xyl"?>

&amp;lt;overlay xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;div id="main">
    &amp;lt;p>&amp;lt;a href="@i">☜ Back to list&amp;lt;/a>&amp;lt;/p>

    &amp;lt;yield bind="?article">
      &amp;lt;h2 bind="?title" />
      &amp;lt;p bind="?content" />
    &amp;lt;/yield>

    &amp;lt;h2>Comments&amp;lt;/h2>
    &amp;lt;comment bind="?comments" />
  &amp;lt;/div>
&amp;lt;/overlay></code></pre>
  <p>Les données concernant l'article se trouvent dans l'arbre
  <code>article</code> et les commentaires dans les arbres
  <code>comments</code>. Nous noterons le lien pour revenir à la liste des
  articles basé sur la règle <code>i</code> du routeur qui ne comporte aucune
  variable d'où sa grande simplicité.</p>
  <p>Et la déclaration de notre composant <code>comment</code> se fait de la
  manière suivante :</p>
  <pre><code class="language-markup">&amp;lt;?xml version="1.0" encoding="utf-8"?>

&amp;lt;definition xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;yield name="comment">
    &amp;lt;div class="comment">
      &amp;lt;ul>
        &amp;lt;li>
          &amp;lt;span bind="?posted" /> • &amp;lt;span bind="?author" />
          &amp;lt;p bind="?content" />
        &amp;lt;/li>
      &amp;lt;/ul>
    &amp;lt;/div>
  &amp;lt;/yield>
&amp;lt;/definition></code></pre>
  <p>Une fois de plus, les données nécessaires se devinent rapidement.</p>

  <h3 id="Depuis_notre_controleur" for="main-toc">Depuis notre contrôleur</h3>

  <p>Nous allons modifier les deux méthodes de notre contrôleur
  <code>Application\Controller\Blog</code>, respectivement
  <code>IndexAction</code> pour la liste des articles et
  <code>ArticleAction</code> pour un seul article. Les données sont déjà
  extraites, nous allons les donner à XYL. Commençons par
  <code>IndexAction</code> :</p>
  <pre><code class="language-php">public function IndexAction ( ) {

    $article              = new \Application\Model\Article();
    $list                 = $article->getShortList();
    $this->data->title    = 'All articles';
    $this->data->articles = $list;

    $this->view->addOverlay('hoa://Application/View/Blog/Index.xyl');
    $this->view->render();

    return;
}</code></pre>
  <p>Nous déclarons deux données : le titre du document principal et la liste
  des articles. Puis, nous demandons à la vue d'utiliser l'<em>overlay</em>
  correspondant à la liste des articles et d'en faire un rendu. Nous remarquons que
  <code>Hoa\Core\Data</code> représenté par l'attribut <code>data</code>
  comprend bien les données provenant des bases de données (entre autres) : nous
  lui donnons <code>$list</code> sans effectuer aucune opération.</p>
  <p>Le traitement sera similaire pour un article et ses commentaires :</p>
  <pre><code class="language-php">public function ArticleAction ( $id ) {

    $article              = new \Application\Model\Article();
    $article->id          = $id;
    $article->open();
    $this->data->title    = $article->title;
    $this->data->article  = $article;
    $this->data->comments = $article->comments;

    $this->view->addOverlay('hoa://Application/View/Blog/Article.xyl');
    $this->view->render();

    return;
}</code></pre>

  <h3 id="Testons" for="main-toc">Testons !</h3>

  <p>Avant de tester, nous devons modifier notre fichier d'amorçage
  <code>index.php</code> pour préciser à notre dispatcheur en second argument
  qu'il doit utiliser <code>Hoa\Xyl</code> comme vue :</p>
  <pre><code class="language-php">Hoa\Database\Dal::initializeParameters(array(
    'connection.list.default.dal' => Hoa\Database\Dal::PDO,
    'connection.list.default.dsn' => 'sqlite:hoa://Data/Variable/Database/Blog.sqlite',
    'connection.autoload'         => 'default'
));

$dispatcher = new Hoa\Dispatcher\Basic();
$router     = new Hoa\Router\Http();
$router->get('i', '/', 'blog', 'index')
       ->get('a', '/article-(?&amp;lt;id>\d+)\.html', 'blog', 'article');

try {

    $dispatcher->dispatch(
        $router,
        new Hoa\Xyl\Xyl(
            new Hoa\File\Read('hoa://Application/View/Main.xyl'),
            new Hoa\Http\Response\Response(),
            new Hoa\Xyl\Interpreter\Interpreter\Html\Html(),
            $router
        )
    );
}
catch ( Hoa\Router\Exception\NotFound $e ) {

    echo 'Your page seems to be not found /o\.', "\n";
}</code></pre>
  <p>Depuis un navigateur en allant sur
  <a href="http://127.0.0.1:8888/"><code>127.0.0.1:8888</code></a>, nous verrons
  notre document rendu en HTML et plus précisément la liste des articles
  présents sur le blog. De même en allant sur
  <a href="http://127.0.0.1:8888/article-0.html"><code>127.0.0.1:8888/article-0.html</code></a>
  nous verrons le premier article du blog.</p>
  <p>Notons que les dates s'affichent toujours en format timestamp. Nous verrons
  comment résoudre ce problème sans passer par le contrôleur mais avec XYL
  uniquement.</p>

  <h3 id="Avec_des_ressources">Avec des ressources</h3>

  <p>Quelques styles, images, polices etc. sont disponibles sur
  <a href="http://hg.hoa-project.net/Sandbox">le dépôt <code>Sandbox/</code></a>
  dans le dossier <code>GordonsBlog/Application/Public/Classic/</code>. Nous
  pouvons les copier dans notre même dossier
  <code>Application/Public/Classic/</code>. Pour les utiliser, nous allons
  ajouter la feuille de style <code>Css/UI.css</code> à notre document
  principal :</p>
  <pre><code class="language-markup">&amp;lt;?xml version="1.0" encoding="utf-8"?>
&amp;lt;?xyl-stylesheet href="hoa://Application/Public/Css/UI.css"?>

&amp;lt;document xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;title>&amp;lt;value bind="?title" /> — Gordon's blog&amp;lt;/title>
  …</code></pre>
  <p>Si nous retournons sur notre application, nous verrons que les styles sont
  appliqués ! Vous trouverez plus de détails sur l'utilisation des ressources
  dans le <a href="@ll:chapter=Xyl#Ressources_de_l-application_et_theme">
  chapitre XYL</a> du manuel d'apprentissage.</p>

  <h2 id="Conclusion" for="main-toc">Conclusion</h2>

  <p>Ce mini-tutorial touche à sa fin sur une application certes basique mais
  fonctionnelle et qui illustre les concepts de base de Hoa et son aspect
  framework.</p>

  <p>Le détail du fonctionnement et l'esprit des bibliothèques mises en œuvre
  ici sont présentés dans le <a href="@l#Manuel_d-apprentissage">
  manuel d'apprentissage</a> avec des exemples détaillés. Le
  <em>Gordon's blog</em> est l'exemple fil rouge du manuel d'apprentissage.</p>

</yield>
</overlay>
